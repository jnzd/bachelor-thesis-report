\chapter{Implementation and Evaluation}

\section{Wrapping MonPoly}



The wrapper runs MonPoly as a subprocess and handles all interactions with MonPoly itself.
Incoming events are first parsed and checked on some major formatting errors.
When the formatting is deemed acceptable the events get forwarded to MonPoly on a per time point basis.
If MonPoly reports an issue with a certain time stamp, either it is out of order or one event at that timestamp does not comply with the given signature, this time stamp gets ignored by MonPoly, and in turn the wrapper discards it as well.
If no issue is detected with a timestamp all events in at that timestamp get forwarded to the database.

\subsection{Performance}


\section{Policy Change}
% \input{diagrams/actions.tex}

\begin{figure}
    \label{fig:flowchart}
    \centering
    % \includegraphics[width=110mm]{diagrams/flowchart.png}
    \includegraphics[width=\linewidth]{diagrams/flowchart-2.png}
    \caption{Control flow for a new event}
\end{figure}

This first version of a policy change functions by stopping the current monitor and starting a new one.
When starting the new monitor we want to restore the state of the old one.
We do this by querying old events from our database.
But we do not simply query for the entirety of the database.
We make two optimizations.
First we use relative intervals and second we make use of constant values.
For each predicate occurring in a formula we look for constant attributes in its occurrences.
For every predicate and its potential occurrences with different constant values we then compute an over approximation of the relative interval.
We use this information to create a SQL query that only queries the constant values combined with the interval.
This way we minimize the amount of data that the new monitor has to read and process.


\section{Partial Policy Change}

