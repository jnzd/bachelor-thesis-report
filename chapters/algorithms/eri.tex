\section{Relative Interval Extension}

This idea of relative intervals can already filter an existing trace down to a much smaller one by removing events that are unnecessary for the evaluation of a given policy.
We expand on this by creating and using a data structure that allows us to select an even smaller sub trace with the same effect of not changing the truth value of the policy.

First we move from one relative interval for an entire policy to one relative interval per predicate occurring in a policy.
We break this down further.
Every predicate comes with a number of attributes as defined in the signature.
Some attributes are potentially constant.
Looking back at our example from earlier, \texttt{"advertising"} is one such constant attribute in the predicate \texttt{loc\_accessed}.

\begin{verbatim}
loc_accessed(i, "advertising") 
IMPLIES 
(
    (ONCE[0,*) perm_granted(i)) 
    AND 
    (NOT (perm_revoked(i) SINCE[0,*) perm_granted(i)))
)
\end{verbatim}

This means any occurrence of the predicate \texttt{loc\_accessed} where the second attribute is not \texttt{"advertising"}, has no influence on our policy and is therefore not needed in a potential sub trace.
We check every predicate in our policy for constant attributes.
Then we take the set of different arrangements of constant and variable attributes per predicate.
We call one such arrangement a mask.
Each mask has its own relative interval.
For our example the masks with their corresponding relative intervals are the following.

\begin{verbatim}
loc_accessed(*,"advertising") -> [0,0]
perm_granted(*) -> (*,0]
perm_revoked(*) -> (*,0]
\end{verbatim}

A \texttt{*} in the attributes denotes a variable value.
In larger formulas there can be multiple different masks per predicate.

We use a doubly nested map data structure to store the predicates with there masks and relative intervals and call such a structure the extended relative intervals of a formula.
On the first level the keys are predicate names and values are maps from masks to intervals.
On this data structure we define the operators $\Cupmerge$, $\Cupext$ and $\oplusext$.

\begin{definition}
    Let $m$ and $n$ be two extended relative intervals and $i$ a positive interval, then 
    \begin{align*}
        m \Cupmerge n = 
            & \{ p(l) \rightarrow (i \Cup j) \mid 
                p(l) \rightarrow i \in m \text{ and } 
                p(l) \rightarrow j \in n \} \\
            & \cup \{p(l) \rightarrow i \mid  
                (p(l) \rightarrow i \in m \text{ and }
                p(l) \in \keys(m) \setminus \keys(n)) \} \\
            & \cup \{p(l) \rightarrow i \mid  
                (p(l) \rightarrow i \in n \text{ and }
                p(l) \in \keys(n) \setminus \keys(m))
                \}        
                \\
        i \Cupext m = 
            & \{ p(l) \rightarrow (i \Cup j) \mid 
                p(l) \rightarrow j \in m \} \\
        i \oplusext m = 
            & \{ p(l) \rightarrow (i \oplus j) \mid 
                p(l) \rightarrow j \in m \} \\
    \end{align*}
\end{definition}

The notation $p(l) \rightarrow i$ denotes an element in our doubly nested map structure.
$p$ is a first level key, i.e. a predicate name, $l$ is a second level key, i.e. a mask and $i$ denotes the interval the key combination $p(l)$ is pointing to.
The $\keys$ operator gives all combinations of outer keys (predicate names) and inner keys (masks) in an extended relative intervals structure.
With the help of the operators $\Cupmerge$, $\Cupext$ and $\oplusext$ we now give a recursive definition for our extended relative intervals.
% In addition we need to helper functions $\inveri(m)$ which inverses all intervals in a map $m$ and $\zeroeri(m)$ which sets the lower bound of all intervals in the map $m$ to zero.

\begin{definition}
    The extended relative interval of the formula $\varphi$, $\ERI(\varphi)$ is defined recursively over the formula structure:
    \begin{equation*}
        \ERI(\varphi) = \\
        \begin{cases}
            \{\} 
                & \text{if $\varphi$ is an an atomic formula} \\ &\text{and not a predicate,} \\ 
            \{p(m) \rightarrow [0,0]\} 
                & \text{if $\varphi$ is a predicate with name } \\ &\text{$p$ and mask $m$,} \\
            \ERI(\psi) 
                & \text{if $\varphi$ is of the form $\neg \psi, \exists x.\psi$,} \\
                & \text{or $\forall x.\psi$,} \\
            \ERI(\psi) \Cupmerge \ERI(\chi) 
                & \text{if $\varphi$ is of the form $\psi \lor \chi$,} \\ & \text{or $\psi \land \chi$,} \\
            (-b,0] \Cupext ((-b,-a] \oplusext \ERI(\psi)) 
                & \text{if $\varphi$ is of the form $\Previous{[a,b)}\psi$,} \\
            [0,b) \Cupext ([a,b) \oplusext \ERI(\psi)) 
                & \text{if $\varphi$ is of the form $\Next{[a,b)}$,}\\
            (-b,0] \Cupext ((-b,0] \oplusext \ERI(\psi)) \Cupmerge ((-b,-a] \oplusext \ERI(\chi)) 
                & \text{if $\varphi$ is of the form $\psi \Since{[a,b)} \chi$,} \\
            [0,b) \Cupext ([0,b) \oplusext \ERI(\psi)) \Cupmerge ([a,b) \oplusext \ERI(\chi)) 
                & \text{if $\varphi$ is of the form $\psi \Until{[a,b)} \chi$,} \\
            [0,b) \Cupext ([0,b) \oplusext \ERIr(\psi)) 
                & \text{if $\varphi$ is of the form $\Fregex{[a,b)} \psi$, and}\\
            (-b,0] \Cupext ((-b,0] \oplusext \ERIr(\psi)) 
                & \text{if $\varphi$ is of the form $\Pregex{[a,b)} \psi$.}\\
        \end{cases}
    \end{equation*}
\end{definition}

And for regular expressions we define 
\begin{definition}
    The extended relative interval of the regular expression $\rho$, $\ERIr(\rho)$ is defined recursively over the structure of the regular expression:
    \begin{equation*}
        \ERIr(\rho) =
        \begin{cases}
            \{\} & \text{if $\rho$ is of the form $\star^k$,} \\
            \ERI(\varphi) & \text{if $\rho$ is of the form $\varphi ?$,} \\
            \ERIr(\sigma) \Cupmerge \ERIr(\tau) & \text{if $\rho$ is of the form $\sigma + \tau$ or $\sigma \cdot \tau$, and} \\
            \ERIr(\sigma) & \text{if $\rho$ is of the form $\sigma^*$.}
        \end{cases}
    \end{equation*}
\end{definition}

\begin{definition}
    We call fine-grained filtering of a trace $\sigma=((\tau_i,D_i))_i$ according to the <name of your datastructure> X the trace 
    
    \begin{equation*}
        \filter'(\sigma, X, j) = ....
    \end{equation*}
\end{definition} 

\begin{theorem}
    For all $\sigma, v, i$:
    \begin{equation*}
        \sigma, v, i \models \varphi 
        \Leftrightarrow \filter'(\sigma, \ERI(\phi), i), v, i \models \varphi
    \end{equation*}
\end{theorem} 

\subsection{Correctness}
Analogous to the definition of $\RI$ we now want to proof that $\varphi$ evaluated on the sub trace $\sigma'$ extracted with $\ERI(\varphi)$ leads to the same truth value as with the full trace $\sigma$.

To get a correct sub trace $\sigma'$ we cannot simply extract the sub trace per predicate and mask.
There are possibly time points and time stamps in the original trace that have no predicate attached to them.
Therefore we additionally need to extract all such time stamps that fall into the regular relative interval of the formula.
Empty time points or time stamps can influence the truth value of a formula and can therefore not be omitted.

The first case of atomic formulas that are not a predicate is trivial.
They do not depend on any events that may or may not be present in a log and can be evaluated as is.
Next a simple predicate only depends on the current time point with time stamp $0$.
For the unary and binary first order logic formulas (negation, quantification, and, or) the extended relative interval is the special union of relative intervals of the sub formula(s).
Special union referring to the operator that keeps the intervals as intervals.