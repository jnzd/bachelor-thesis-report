\section{Relative Interval Extension}

This idea of relative intervals can already filter an existing trace down to a much smaller one by removing events that are unnecessary for the evaluation of a given policy.
We expand on this by creating and using a data structure that allows us to select an even smaller sub trace with the same effect of not changing the truth value of the policy.

First we move from one relative interval for an entire policy to one relative interval per predicate occurring in a policy.
We break this down further.
Every predicate comes with a number of attributes as defined in the signature.
Some attributes are potentially constant.

Looking back at our policy from Figure \ref{fig:example-policy}, \texttt{"advertising"} is one such constant attribute in the predicate \texttt{loc\_accessed}.
This means any occurrence of the predicate \texttt{loc\_accessed} where the second attribute is not \texttt{"advertising"}, has no influence on our policy and is therefore not needed in a potential sub trace.
We check every predicate in our policy for constant attributes.
Then we take the set of different arrangements of constant and variable attributes per predicate.
We define a structure that captures constant and variable attributes of a predicate.
\begin{definition}
    \label{def:mask}
    Let $S=(C,R,\iota)$ be a signature and $r \in R$ a predicate with arity $\iota(r)$.
    A mask for the predicate $r$ is a tuple $m=(m_1, \dots, m_{\iota(r)})$ with $m_1, \dots, m_{\iota(r)} \in C \cup \{v\}$ and $v \not\in V \cup C$.
\end{definition}
$v$ is a placeholder value denoting attributes in the mask that have a non-constant value.
Each mask has its own relative interval.
For our example the masks with their corresponding relative intervals can be seen in Figure \ref{fig:example-ext-intervals}.

\begin{figure}[H]
    \label{fig:example-ext-intervals}
\begin{verbatim}
loc_accessed(*,"advertising") -> [0,0]
perm_granted(*) -> (*,0]
perm_revoked(*) -> (*,0]
\end{verbatim}
    \caption{Extended Relative Intervals of Example Policy}
\end{figure}

A \texttt{*} (asterisk) in the attributes denotes a variable value, $v$ in Definition \ref{def:mask}.
In larger formulas there can be multiple different masks per predicate.
Let $\mathcal{M}(r)$ be the set of possible masks for a predicate $r$.

\begin{definition}
    \label{def:mask-precision-comparison}
    Let $m = (m_1, \dots, m_{\iota(r)})$ and $n = (n_1, \dots, n_{\iota(r)})$ be two masks for a predicate $r \in R$, where $R$ is part of the signature $S = (C,R,\iota)$.
    $m \nomoreprecise n$ denotes that $m$ is no more precise than $n$, i.e. for all $i \in \mathbb{N}$ with $0 \leq i \leq \iota(r)$, $m_i = n_i$ or $m_i = v$.
\end{definition}

We use a map data structure to store the predicates, masks, and their respective relative intervals.

\begin{definition}
    \label{def:map}
    Let $S=(C,R,\iota)$ be a signature and let $\mathcal{M} : R \to \{(C \cup \{v\})^*\}$ be the function $\mathcal{M}(r) = M$ that gives the set of all possible masks $M$ for a predicate $r$.
    A \textbf{masked predicate map} is a set $\{(k,i)\}$ where $k = (r,m)$ with $r \in R$ and $m \in \mathcal{M}(r)$ and $i \subseteq \mathbb{Z}$ is an interval over $\mathbb{Z}$. 
\end{definition}


On this data structure we define the operators $\Cupmerge$, $\Cupext$ and $\oplusext$.

\begin{definition}
    \label{def:e-rel-int-ops}
    Let $M$ and $N$ be two masked predicate maps and $T$ a positive interval, then 
    \begin{align*}
        M \Cupmerge N = 
            & \{ p(l) \rightarrow (I \Cup J) \mid 
                p(l) \rightarrow I \in m \text{ and } 
                p(l) \rightarrow J \in n \} \\
            & \cup \{p(l) \rightarrow I \mid  
                (p(l) \rightarrow I \in m \text{ and }
                p(l) \in \keys(M) \setminus \keys(N)) \} \\
            & \cup \{p(l) \rightarrow I \mid  
                (p(l) \rightarrow I \in n \text{ and }
                p(l) \in \keys(N) \setminus \keys(M))
                \}        
                \\
        T \Cupext M = 
            & \{ p(l) \rightarrow (T \Cup I) \mid 
                p(l) \rightarrow I \in M \} \\
        T \oplusext M = 
            & \{ p(l) \rightarrow (T \oplus I) \mid 
                p(l) \rightarrow I \in M \} \\
    \end{align*}
\end{definition}

The notation $p(l) \rightarrow I$ denotes an element in a masked predicate map.
It is equivalent to the notation $((p,l), I)$, but it better shows how we are working with a map.
The $\keys$ operator gives all the first elements, the predicate name and mask tuples, in a masked predicate map.
With the help of the operators $\Cupmerge$, $\Cupext$ and $\oplusext$ we now give a recursive definition for our extension of relative intervals.

We define a relation on masked predicate maps that is analogous to the subset-equals relation for intervals and illustrates that one map is contained in another.

\begin{definition}
    \label{def:subseteqmap}
    Let $M$ and $N$ be two masked predicate maps.
    \begin{equation*}
        N \subseteqmap M
    \end{equation*}
    if for all $((p,l) \to I) \in N$ there exists $((p',l') \to I') \in M$ with
    \begin{equation*}
        (p = p') \land (l' \nomoreprecise l) \land (I \subseteq I')
    \end{equation*}
\end{definition}

\begin{lemma}
    \label{lem:oplus-and-oplusext}
    Let $I_1, I_2 \subseteq \mathbb{Z}$ be intervals, and $M$ a masked predicate map.
    Then $(I_1 \oplus I_2) \oplusext M = I_1 \oplusext (I_2 \oplusext M)$.
\end{lemma}
\textit{Proof} This follows directly from the definitions of the two operators.
We omit a detailed proof.

\begin{lemma}
    \label{lem:oplusext-zero}
    Let $M$ be a masked predicate map.
    Then $\{0\} \oplusext M = M$.
\end{lemma}
\textit{Proof} This is a direct consequence of the definition of $\oplusext$.
Adding zero to every interval in the map obviously does not change the intervals and thus it also does not change the map itself.

\input{chapters/algorithms/eri-lemmas/map-union-subsets.tex}

\begin{definition}
    \label{def:e-rel-int}
    The extended relative interval of the formula $\varphi$, $\ERI(\varphi)$ is defined recursively over the formula structure:
    \begin{equation*}
        \ERI(\varphi) = \\
        \begin{cases}
            \{\} 
                & \text{if } \varphi \text{ is an atomic formula} \\
                & \text{and not a predicate,} \\ 
                \{p(m) \rightarrow [0,0]\} 
                & \text{if } \varphi \text{ is a predicate with name } \\
                & p \text{ and mask } m, \\
            \ERI(\psi) 
                & \text{if } \varphi \text{ is of the form } \neg \psi, \exists x.\psi, \\
                & \text{or } \forall x.\psi, \\
            \ERI(\psi) \Cupmerge \ERI(\chi) 
                & \text{if } \varphi \text{ is of the form } \psi \lor \chi, \\
                & \text{or } \psi \land \chi, \\
            (-b,0] \Cupext ((-b,-a] \oplusext \ERI(\psi)) 
                & \text{if } \varphi \text{ is of the form } \Previous{[a,b)} \psi, \\
            [0,b) \Cupext ([a,b) \oplusext \ERI(\psi)) 
                & \text{if } \varphi \text{ is of the form } \Next{[a,b)} \psi,\\
            (-b,0] \Cupext ((-b,0] \oplusext \ERI(\psi)) \Cupmerge ((-b,-a] \oplusext \ERI(\chi)) 
                & \text{if } \varphi \text{ is of the form } \psi \Since{[a,b)} \chi, \\
            [0,b) \Cupext ([0,b) \oplusext \ERI(\psi)) \Cupmerge ([a,b) \oplusext \ERI(\chi)) 
                & \text{if } \varphi \text{ is of the form } \psi \Until{[a,b)} \chi, \\
            [0,b) \Cupext ([0,b) \oplusext \ERIr(\psi)) 
                & \text{if } \varphi \text{ is of the form } \Fregex{[a,b)} \psi, \text{ and}\\
            (-b,0] \Cupext ((-b,0] \oplusext \ERIr(\psi)) 
                & \text{if } \varphi \text{ is of the form } \Pregex{[a,b)} \psi.\\
        \end{cases}
    \end{equation*}
\end{definition}

And for regular expressions we define 
\begin{definition}
    \label{def:e-rel-int-reg}
    The extended relative interval of the regular expression $\rho$, $\ERIr(\rho)$ is defined recursively over the structure of the regular expression:
    \begin{equation*}
        \ERIr(\rho) =
        \begin{cases}
            \{\} & \text{if $\rho$ is of the form $\star^k$,} \\
            \ERI(\varphi) & \text{if $\rho$ is of the form $\varphi ?$,} \\
            \ERIr(\sigma) \Cupmerge \ERIr(\tau) & \text{if $\rho$ is of the form $\sigma + \tau$ or $\sigma \cdot \tau$, and} \\
            \ERIr(\sigma) & \text{if $\rho$ is of the form $\sigma^*$.}
        \end{cases}
    \end{equation*}
\end{definition}


\subsection{Correctness}
Analogously to regular intervals we want to use the extended relative intervals to extract (slice) a sub trace from a larger trace for a given formula that has the property that the sub trace is sufficient to evaluate the formula.
We first need a few definitions and lemmas before we can proof this property.
\begin{definition}
    \label{def:matching-predicate}
    Let $\mathcal{D}$ be a structure over the signature $S = (C,R,\iota)$, $r^{\mathcal{D}} \in |\mathcal{D}|$ the set of interpretations for the predicate $r \in R$, and $m$ a mask for $r$.
    The arity of $r$, $\iota(r)$ is the same as the length of the mask $m$, $|m|$.
    The mask $m = (m_1, \dots, m_{\iota(r)})$ matches the interpretation $k = (k_1, \dots, k_{\iota(r)}) \in r^{\mathcal{D}}$ if for all $i \in [1,\iota(r)]$ either $m_i = v$ or $m_i = k_i$, where $v$ is again the placeholder value for variable values.
    We write $m \matches k$ for $m$ matches $k$.
\end{definition}

\input{chapters/algorithms/eri-lemmas/mask-precision-lemma.tex}

\begin{definition}
    \label{def:filter}
    Let $M$ be a masked predicate map, $\tau_i, tau_j \in \mathbb{N}$ two time stamps, and $\mathcal{D}$ a structure over the signature $S = (C,R,\iota)$.
    Let $\mathbb{D}$ be the set of all structures over the signature $S$.
    $\filter(M, \mathcal{D}, \tau_i, \tau_j) : \mathbb{D} \to \mathbb{D}$ is a function filtering the structure $\mathcal{D}$ on the condition whether $\tau_i$ is in the relative intervals of the masked predicates in $M$ shifted by $\tau_j$.
    Constant interpretations remain unchanged by the the filtering.
    Concretely for all $r \in R$, 
    \begin{equation*}
        r^{\filter(M, \mathcal{D}, \tau_i, \tau_j)} 
        = \{v(\bar{t}) \in r^{\mathcal{D}} \mid 
            \exists ((p,m), I) \in M. 
                p = r \land m \matches v(\bar{t}) 
                \land \tau_i - 
                \tau_j \in I \}.
    \end{equation*}
\end{definition}
Intuitively $\tau_j$ can be seen as the reference time stamp and we check whether a time stamp $\tau_i$ lies inside the relative intervals from the perspective of $\tau_j$.
The following lemma states that filtering a structure twice has the same effect as filtering once.

\input{chapters/algorithms/eri-lemmas/double-filter.tex}


Basin et al. \cite{Basin2016} defines a \textit{slice} of a temporal structure in Definition 3.1.
We restate this definition here.
(In the definition $R$ is part of a signature $S=(C,R,\iota)$.)
\begin{definition}
    \label{def:slice}
    Let $s : [0,l) \to \mathbb{N}$ be a strictly increasing function, with $l \in \mathbb{N} \cup \{\infty\}$.
    The temporal structure $(\bar{\mathcal{D}}', \bar{\tau}')$ is a \textit{slice} of $(\bar{\mathcal{D}}, \bar{\tau})$ (with respect to the function $s$) if $\tau_{i'} = \tau_{s(i)}$ and $r^{\mathcal{D}'_i} \subseteq r^{\mathcal{D}_{s(i)}}$, for all $i \in [0,l)$ and all $r \in R$.
\end{definition}

Basin et al. \cite{Basin2016} further defines a $T$-slice in Definition A.2 for slicing a temporal structure in a temporal manner.
We define an analogous notion of an $MT_{\tau}$- slice which is a more fine-grained way of slicing that makes use of masked predicate maps.
\begin{definition}
    \label{def:mt-slice}
    Let $T \subseteq \mathbb{Z}$ be an interval,
        and $M$ a masked predicate map
            where for all $(m, J) \in M$, $J \subseteq T$.
    And let $(\bar{\mathcal{D}}, \bar{\tau})$ a temporal structure.
    The $MT_{\tau}$- slice of $(\bar{\mathcal{D}}, \bar{\tau})$ is the time slice $(\bar{\mathcal{D}}', \bar{\tau}')$ of $(\bar{\mathcal{D}}, \bar{\tau})$, where $s:[0,l) \to \mathbb{N}$ is the function $s(i') = i' + c, l = |\{i \in \mathbb{N} \mid \tau_i \in T\}|$, and $c = \min\{i \in \mathbb{N} \mid \tau_i \in T \}$. 
    We also require that $\tau_l' \not\in T$ and 
    \begin{equation*}
        \mathcal{D}'_{i'} = \filter(M, \mathcal{D}_{s(i')}, \tau_{s(i')}, \tau),
    \end{equation*}
    for all $i' \in [0,l)$.
\end{definition}


\begin{definition}
    \label{def:overlapping-ext}
    Let $I \subseteq \mathbb{Z}$ be an interval, and $M$ be a masked predicate map where for all $(m, J) \in M$, $J \subseteq I$.
    Let $c,i \in \mathbb{N}$.
    The temporal structures $(\bar{\mathcal{D}}, \bar{\tau})$ and $(\bar{\mathcal{D}}', \bar{\tau}')$ are $(M,I,c,i)$-overlapping if the following conditions hold:
    \renewcommand{\labelenumi}{\arabic{enumi}.}
    \begin{enumerate}
        \item 
            $j \geq c$,
            $\tau_j = \tau'_{j-c}$,
            and
            \begin{equation*}
                \filter(M, \mathcal{D}_j, \tau_j, \tau_i)
                = \filter(M, \mathcal{D}'_{j-c}, \tau'_{j-c}, \tau_i)
            \end{equation*}
            for all $j \in \mathbb{N}$ with $\tau_j - \tau_i \in I$,
        \item
            $\tau_{j'+c} = \tau'_{j'}$,
            and
            \begin{equation*}
                \filter(M, \mathcal{D}_{j'+c}, \tau_{j'+c}, \tau_i)
                = \filter(M, \mathcal{D}'_{j'}, \tau'_{j'}, \tau_i)
            \end{equation*}
            for all $j' \in \mathbb{N}$ with $\tau'_{j'} - \tau_i \in I$,
    \end{enumerate}
\end{definition}

The next lemma establishes that a trace and its $MT_{\tau_i}$- slice are $(M,T,c,i)$- overlapping.
It is analogous to Lemma A.2 in Basin et al. \cite{Basin2016}.
\input{chapters/algorithms/eri-lemmas/slice-overlap.tex}


Analogous to Lemma A.3 in Basin et al. \cite{Basin2016} the following Lemma states that any overlapping traces also overlap on parts of the overlapping section.
\input{chapters/algorithms/eri-lemmas/overlap-transitivity.tex}

With this we get to the key Lemma that we rely on to make our optimization when selecting and querying a sub-trace from the database.
It is analogous to Lemma A.4 in Basin et al. \cite{Basin2016}.
\input{chapters/algorithms/eri-lemmas/eri-overlap.tex}



%%% Justification/ intuition for also getting all time points inside the entire regular interval
To get a correct sub trace $\sigma'$ we cannot simply extract the sub trace per predicate and mask.
There are possibly time points and time stamps in the original trace that have no predicate attached to them.
Therefore we additionally need to extract all such time stamps that fall into the regular relative interval of the formula.
Empty time points or time stamps can influence the truth value of a formula and can therefore not be omitted.

The first case of atomic formulas that are not a predicate is trivial.
They do not depend on any events that may or may not be present in a log and can be evaluated as is.
Next a simple predicate only depends on the current time point with time stamp $0$.
For the unary and binary first order logic formulas (negation, quantification, and, or) the extended relative interval is the special union of relative intervals of the sub formula(s).
Special union referring to the operator that keeps the intervals as intervals.