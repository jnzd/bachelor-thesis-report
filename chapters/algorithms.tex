\chapter{Algorithms}

\section{Policy Change}
This section gives a high level view of our policy change method.
The individual parts of the policy change will be explained in the following sections of this chapter.
We have a running instance of MonPoly monitoring some policy.
The user asks the wrapper to monitor a new policy.
The wrapper checks the monitorability of the new policy against the existing policy.
If it is not monitorable the wrapper keeps the current instance of MonPoly running and reports the issue with the new policy to the user.
Otherwise the wrapper uses MonPoly to get the extended relative intervals of the new policy.
Then these extended relative intervals get converted to SQL queries and the wrapper runs these queries on QuestDB.
The response from QuestDB gets converted into a MonPoly log file.
Next the wrapper stops the current iteration of MonPoly and starts a new one that first reads the created log file.
At this point the policy change is done, and the wrapper can continue with its normal operation.

% \textit{TODO write some pseudo code here}


\section{Relative Intervals}

First we append the definition of relative intervals from Basin et al. \cite{Basin2016} to include all operators currently supported by MonPoly.
Namely we add definitions for the MFODL operators.
Intervals are defined over $\mathbb{Z}$ and can either be open or closed.
The operators $\oplus$ and $\Cup$ are defined the same way as in Basin et al. \cite{Basin2016}.
Let $I$ and $J$ be some arbitrary intervals then $I \oplus J := \{i+j \mid i \in I \text{ and } j \in J\}$ and $I \Cup J$ is the smallest interval containing all values in both $I$ and $J$.

\begin{equation*}
    \RI(\varphi) =
    \begin{cases}
        \{0\}     & \text{if $\varphi$ is an an atomic formula,} \\ 
        \RI(\psi) & \text{if $\varphi$ is of the form $\neg \psi$, 
                            $\exists x.\psi$,} \\ &\text{or $\forall x.\psi$,} \\
        \RI(\psi) \Cup \RI(\chi) & \text{if $\varphi$ is of the form $\psi \lor \chi, or
                                         \psi \land \chi$,} \\
        (-b,0] \Cup ((-b,-a] \oplus \RI(\psi)) & \text{if $\varphi$ is of the form $\Previous_{[a,b)}\psi$,} \\
        [0,b) \Cup ([a,b) \oplus \RI(\psi)) & \text{if $\varphi$ is of the form $\Next_{[a,b)}$,}\\
        (-b,0] \Cup ((-b,0] \oplus \RI(\psi)) \Cup ((-b,-a] \oplus \RI(\chi)) & \text{if $\varphi$ is of the form $\psi \Since_{[a,b)} \chi$,} \\
        [0,b) \Cup ([0,b) \oplus \RI(\psi)) \Cup ([a,b) \oplus \RI(\chi)) & \text{if $\varphi$ is of the form $\psi \Until_{[a,b)} \chi$,} \\
        [0,b) \Cup ([0,b) \oplus \RIr(\rho)) & \text{if $\varphi$ is of the form $\Fregex_{[a,b)} \rho$, and}\\
        (-b,0] \Cup ((-b,0] \oplus \RIr(\rho)) & \text{if $\varphi$ is of the form $\Pregex_{[a,b)} \rho$.}\\
    \end{cases}
\end{equation*}

We recursively define the relative interval of regular expressions as seen in Basin et al. \cite{Basin2020} in the following way.

\begin{equation*}
    \RIr(\rho) =
    \begin{cases}
        \{0\} & \text{if $\rho$ is of the form $\star^k$,} \\
        \RI(\varphi) & \text{if $\rho$ is of the form $\varphi?$,} \\
        \RIr(\sigma) \Cup \RIr(\tau) & \text{if $\rho$ is of the form $\sigma + \tau$ or $\sigma \cdot \tau$, and} \\
        \RIr(\sigma) & \text{if $\rho$ is of the form $\sigma^*$.}

    \end{cases}
\end{equation*}

\subsection{Correctness}
% TODO
Basin et al. \cite{Basin2016} provides an intuition for why the definition of $\RI$ is correct for the MFOTL operators.
Here we provide the same for the added MFODL \cite{Basin2020} operators and the regular expressions.

The definition of relative intervals is correct if any formula $\varphi$ evaluated on a trace $\sigma$ has the same truth value as evaluated on a trace $\sigma'$ that is a filtered version of $\sigma$ based on $\RI(\varphi)$.
Let $\RI(\varphi) = [a,b)$ where $a,b \in \mathbb{Z}, \, a \leq 0, \, b > 0$.
Given that no future events can be extracted from a trace as they have not happened yet, the extracted trace $\sigma'$ only contains time points with time stamps that are in the interval $[a,0]$.
Formally $\sigma' = \{x \mid x \in \sigma \text{ and } x.ts \in [a,0]\}$, where $x.ts$ denotes the time stamp of $x$.

The future match operator $\Fregex_I \rho$ depends on the relative interval of $\rho$ shifted by the interval $I$.
Similarly the past match operator $\Pregex_I \rho$ depends on the relative interval of $\rho$ shifted by the inverted interval $I$.
The interpretation of the relative intervals for regular expressions is a bit different from that of a formula.
Its relevance is the amount that the "parent" interval of a past or future match operator needs to be shifted by.
The wildcard operator $\star^k$ doesn't have any interval information attached.
The parameter $k$ refers to a number of timepoints, but not directly to time stamps.
The test operator $\varphi ?$ is more involved.
It evaluates a formula $\varphi$ which of course has a regular relative interval.
Depending on which match operator is used we want to evaluate $\varphi$ with any starting point inside the specified past or future interval.




\section{Relative Interval Extension}

This idea of relative intervals can already filter an existing trace down to a much smaller one by removing events that are unnecessary for the evaluation of a given policy.
We expand on this by creating and using a data structure that allows us to select an even smaller sub trace with the same effect of not changing the truth value of the policy.

First we move from one relative interval for an entire policy to one relative interval per predicate occurring in a policy.
We break this down further.
Every predicate comes with a number of attributes as defined in the signature.
Some attributes are potentially constant.
Looking back at our example from earlier, \texttt{"advertising"} is one such constant attribute in the predicate \texttt{loc\_accessed}.

\begin{verbatim}
loc_accessed(i, "advertising") 
IMPLIES 
(
    (ONCE[0,*) perm_granted(i)) 
    AND 
    (NOT (perm_revoked(i) SINCE[0,*) perm_granted(i)))
)
\end{verbatim}

This means any occurrence of the predicate \texttt{loc\_accessed} where the second attribute is not \texttt{"advertising"}, has no influence on our policy and is therefore not needed in a potential sub trace.
We check every predicate in our policy for constant attributes.
Then we take the set of different arrangements of constant and variable attributes per predicate.
We call one such arrangement a mask.
Each mask has its own relative interval.
For our example the masks with their corresponding relative intervals are the following.

\begin{verbatim}
loc_accessed(*,"advertising") -> [0,0]
perm_granted(*) -> (*,0]
perm_revoked(*) -> (*,0]
\end{verbatim}

A \texttt{*} in the attributes denotes a variable value.
In larger formulas there can be multiple different masks per predicate.

We use a doubly nested map data structure to store the predicates with there masks and relative intervals and call such a structure the extended relative intervals of a formula.
On the first level the keys are predicate names and values are maps from masks to intervals.
On this data structure we define the operators $\Cupmerge$, $\Cupext$ and $\oplusext$.
Let $m$ and $n$ be two extended relative intervals and $i$ a positive interval, then 
\begin{align*}
    m \Cupmerge n = 
        & \{ p(l) \rightarrow (i \Cup j) \mid 
            p(l) \rightarrow i \in m \text{ and } 
            p(l) \rightarrow j \in n \} \\
        & \cup \{p(l) \rightarrow i \mid  
            (p(l) \rightarrow i \in m \text{ and }
            p(l) \in \keys(m) \setminus \keys(n)) \} \\
        & \cup \{p(l) \rightarrow i \mid  
            (p(l) \rightarrow i \in n \text{ and }
            p(l) \in \keys(n) \setminus \keys(m))
            \}        
            \\
    i \Cupext m = 
        & \{ p(l) \rightarrow (i \Cup j) \mid 
            p(l) \rightarrow j \in m \} \\
    i \oplusext m = 
        & \{ p(l) \rightarrow (i \oplus j) \mid 
            p(l) \rightarrow j \in m \} \\
\end{align*}

The notation $p(l) \rightarrow i$ denotes an element in our doubly nested map structure.
$p$ is a first level key, i.e. a predicate name, $l$ is a second level key, i.e. a mask and $i$ denotes the interval the key combination $p(l)$ is pointing to.
The $\keys$ operator gives all combinations of outer keys (predicate names) and inner keys (masks) in an extended relative intervals structure.
With the help of the operators $\Cupmerge$, $\Cupext$ and $\oplusext$ we now give a recursive definition for our extended relative intervals.
% In addition we need to helper functions $\inveri(m)$ which inverses all intervals in a map $m$ and $\zeroeri(m)$ which sets the lower bound of all intervals in the map $m$ to zero.

\begin{equation*}
    \ERI(\varphi) = \\
    \begin{cases}
        \{\} 
             & \text{if $\varphi$ is an an atomic formula} \\ &\text{and not a predicate,} \\ 
        \{p(m) \rightarrow [0,0]\} 
            & \text{if $\varphi$ is a predicate with name } \\ &\text{$p$ and mask $m$,} \\
        \ERI(\psi) 
            & \text{if $\varphi$ is of the form $\neg \psi, \exists x.\psi$,} \\
            & \text{or $\forall x.\psi$,} \\
        \ERI(\psi) \Cupmerge \ERI(\chi) 
            & \text{if $\varphi$ is of the form $\psi \lor \chi$,} \\ & \text{or $\psi \land \chi$,} \\
        (-b,0] \Cupext ((-b,-a] \oplusext \ERI(\psi)) 
            & \text{if $\varphi$ is of the form $\Previous_{[a,b)}\psi$,} \\
        [0,b) \Cupext ([a,b) \oplusext \ERI(\psi)) 
            & \text{if $\varphi$ is of the form $\Next_{[a,b)}$,}\\
        (-b,0] \Cupext ((-b,0] \oplusext \ERI(\psi)) \Cupmerge ((-b,-a] \oplusext \ERI(\chi)) 
            & \text{if $\varphi$ is of the form $\psi \Since_{[a,b)} \chi$,} \\
        [0,b) \Cupext ([0,b) \oplusext \ERI(\psi)) \Cupmerge ([a,b) \oplusext \ERI(\chi)) 
            & \text{if $\varphi$ is of the form $\psi \Until_{[a,b)} \chi$,} \\
        [0,b) \Cupext ([0,b) \oplusext \ERIr(\psi)) 
            & \text{if $\varphi$ is of the form $\Fregex_{[a,b)} \psi$, and}\\
        (-b,0] \Cupext ((-b,0] \oplusext \ERIr(\psi)) 
            & \text{if $\varphi$ is of the form $\Pregex_{[a,b)} \psi$.}\\
    \end{cases}
\end{equation*}

And for regular expressions we define 
\begin{equation*}
    \ERIr(\rho) =
    \begin{cases}
        \{\} & \text{if $\rho$ is of the form $\star^k$,} \\
        \ERI(\varphi) & \text{if $\rho$ is of the form $\varphi ?$,} \\
        \ERIr(\sigma) \Cupmerge \ERIr(\tau) & \text{if $\rho$ is of the form $\sigma + \tau$ or $\sigma \cdot \tau$, and} \\
        \ERIr(\sigma) & \text{if $\rho$ is of the form $\sigma^*$.}
    \end{cases}
\end{equation*}

\subsection{Correctness}
Analogous to the definition of $\RI$ we now want to proof that $\varphi$ evaluated on the sub trace $\sigma'$ extracted with $\ERI(\varphi)$ leads to the same truth value as with the full trace $\sigma$.

To get a correct sub trace $\sigma'$ we cannot simply extract the sub trace per predicate and mask.
There are possibly time points and time stamps in the original trace that have no predicate attached to them.
Therefore we additionally need to extract all such time stamps that fall into the regular relative interval of the formula.
Empty time points or time stamps can influence the truth value of a formula and can therefore not be omitted.

The first case of atomic formulas that are not a predicate is trivial.
They do not depend on any events that may or may not be present in a log and can be evaluated as is.
Next a simple predicate only depends on the current time point with time stamp $0$.
For the unary and binary first order logic formulas (negation, quantification, and, or) the extended relative interval is the special union of relative intervals of the sub formula(s).
Special union referring to the operator that keeps the intervals as intervals.



\section{Conversion to SQL-Query}


