\chapter{Background}

\section{Metric First-Order Temporal Logic}
As mentioned in the introduction, Metric First-Order Temporal Logic (MFOTL) \cite{Basin2008, Basin2015, Chomicki1995} is used as a policy specification language by MonPoly.
Here we give a quick overview of MFOTL.
MFOTL is well suited to express a variety of policies one might want to monitor.
It combines First Order Logic (FOL) with metric temporal operators.
FOL provides us with common logic operators like $\land$ ("and"), $\lor$ ("or"), and $\neg$ ("not") as well as quantifiers $\forall$ ("for all") and $\exists$ ("exists").
The metric temporal operators in MFOTL are $\Until_I$ ("until"), $\Since_I$ ("since"), $\Previous_I$ ("previous"), and $\Next_I$ ("next").
These operators can be used to construct further syntactic sugar operators such as $\Once_I$ ("once"), $\Eventually_I$ ("eventually"), $\Always_I$ ("always"), and $\Historically_I$ ("historically").
See Basin et al. \cite{Basin2015} for the concrete derivations of these additional operators.
The metric aspect of these operators is the interval $I$ they are bound by.
This interval denotes a time frame in which the formula needs to be satisfied.

Basin et al. \cite{Basin2008} define the syntax and semantics of MFOTL.


Metric First-Order \textit{Dynamic} Logic (MFODL) \cite{Basin2020} is an even more expressive specification language than MFOTL.
MFODL introduces the notion of regular expressions.
For an exact definition of these regular expressions and the two new operators they introduce see figure 4 of Basin et al. \cite{Basin2020}.
Similarly to how $\Once_I$, $\Eventually_I$, $\Always$, and $\Historically$ can be derived from the four core operators $\Until_I$, $\Since_I$, $\Previous_I$, and $\Next_I$, these core operators could theoretically be replaced by the two new regular expression operators.
The exact conversion can also be seen in Basin et al. \cite{Basin2020}.
In practice, it is often useful to keep the basic temporal operators as we can apply specialized optimizations to them that cannot be done with regular expressions.

Basin et al. \cite{Basin2015aggregations} extends MFOTL with aggregations.
Aggregation operations like SUM are commonly seen in database contexts.
When considering an example like a monthly spending limit for a credit card it becomes clear how aggregations can be useful in policy monitoring.


\section{MonPoly}
MonPoly \cite{Basin2017} is a policy monitoring tool written in OCaml that supports MFOTL with aggregations and in its newest iterations it also has support for MFODL.
MonPoly can monitor a fragment of MFOTL/MFODL where all future operators must be bounded.
One major exception to that rule is an (implicit) always operator around the desired policy.

Let's return to the social media example from the introduction and look at how we would go about monitoring that policy with MonPoly.
We recall our description in words:
    "If a user's location data is accessed and the purpose of the access is for tailoring advertisements, the user must have previously given permission for there location data to be used for advertising purposes"
In MonPoly a policy is tied to a signature.
A signature can be compared with a database schema and describes the arity and types of possible events.
So let's consider a possible signature for our example: 

\begin{verbatim}
loc_accessed(user_id: int, purpose: string)
perm_granted(user_id: int)
perm_revoked(user_id: int)
\end{verbatim}

This is a basic signature with 3 predicates.
The first one means that a users location data has been used for a specified purpose.
The last two events get triggered when a user either grants or revokes permission for their location data to be used for advertising purposes.
Let's now define the policy in a formal manner.
\begin{align*}
    \Always (\texttt{loc\_accessed(i, "advertising")}
    \implies (\Once_{[0,\infty)} &\texttt{perm\_granted(i)} \\
         \land  \neg (\texttt{perm\_revoked(i)} \Since_{[0,\infty)} 
            &\texttt{perm\_granted(i)})))
\end{align*}

For MonPoly we first get rid of the surrounding $\Always$, because MonPoly implicitly adds an always-operator around any policy.
The remaining formula in MonPoly syntax is the following:

\begin{verbatim}
loc_accessed(i, "advertising")
IMPLIES 
(
    (ONCE[0,*) perm_granted(i)) 
    AND 
    (NOT (perm_revoked(i) SINCE[0,*) perm_granted(i)))
)
\end{verbatim}

While MonPoly cannot actually monitor this formula directly, it can monitor the negation of this formula.
For this on can use the \texttt{-negate} flag when running MonPoly.

\section{Time Series Databases}

Time series databases are a class of databases optimized for timestamped data.
For example, they optimize for data retrieval within a certain time range.
With the advance of internet of things devices with built-in sensors time series databases are experiencing explosive growth.
And as we have established they happen to fit well with our monitoring goals.
There are many different options of time series databases available.
We were looking for something with good performance, good support for tables of data, and good usability.
We have opted for QuestDB \cite{questdb}.

QuestDB uses a column-based storage model \cite{questdb-storage-model}.
It supports the PostgreSQL wire protocol \cite{questdb-postgres-wire} for querying and inserting data.
% TODO describe protocol
It further provides a REST API and has a web console for both inserting and querying data.
For best performance it supports the InfluxDB Line Protocol \cite{questdb-influx-db-line-protocol} with client libraries for most popular modern programming languages.
% TODO describe protocol
QuestDB itself is written in Java, open source, and licensed under the Apache 2.0 license.
% TODO describe addition of timestamp in rows
% TODO describe form of queries
 


